-- scoring functions for texdoc
--[[ 
Copyright 2008, 2009 Manuel Pégourié-Gonnard
Distributed under the terms of the GNU GPL version 3 or later.
See texdoc.tlu for details.
--]]

local L = {}
load_env(L, {
    'export_symbols',
    'string', 'table',
    'ipairs', 'tostring',
    'config', 'parse_zip', 'err_print', 'deb_print',
})

-- return the "quality" of docfile
function docfile_quality(df)
    if df.score > 0 then
        return 'good'
    elseif df.score > -100 then
        return 'bad'
    else
        return 'killed'
    end
end

-- sort a doclist
function sort_doclist(dl)
    dl:stop()
    set_list_scores(dl)
    table.sort(dl, docfile_order)
end

-- set the scores for a doclist
function set_list_scores(list)
    for _, df in ipairs(list) do
        set_score(df)
    end
end

-- set the score of a docfile
function set_score(df)
    local score = 0
    deb_print('score', 'Start scoring '..df.realpath)
    for _, pat in ipairs(df.matches) do
        local s = match_score(df.name, pat.name)
        s = s * pat.ratio
        deb_print('score', string.format(
            "For pattern '%s': score '%d' ratio '%d'",
            pat.name, tostring(s), tostring(pat.ratio)))
        if s > score then score = s end
    end
    deb_print('score', 'Final score: '..tostring(score))
    df.score = score
end

-- compute a matching score 0 <= s < 10 
-- 0 iff pat or a derivative doesn't match at least as a subword
function match_score(file, pat)
    -- scoring is irrelevant in regex mode
    if config.mode == 'regex' then return 0 end
    -- be case-insensitive
    file = string.lower(file)
    pat = string.lower(pat)
    local score = 0
    -- look for exact match
    if is_exact(file, pat) then
        score = 2
    end
    -- look for subword match
    if is_subword(file, pat) then
        score = 1
    end
    return score
end

-- says if file is an exact match for pat
-- TODO: what to do is pat contains '/' ?
-- TODO: zipped
function is_exact(file, pat)
    basename = string.gsub(file, '^.*/', '')
    if basename == pat then return true end
    for _, ext in ipairs(config.ext_list) do
        if ext ~= '' and ext ~= '*' and basename == pat..'.'..ext then
            return true
        end
    end
    return false
end

-- say if pat is a "subword" of str
function is_subword(str, pat)
    local i, j = string.find(str, pat, 1, true)
    if i and j
        and (i == 1 or is_delim(str, i-1))
        and (j == #string or is_delim(str, j+1)) then
        return true
    else
        return false
    end
end

-- say if chararcter i of str is not a word character
function is_delim(str, i)
    if string.find(string.sub(str, i, i), '%w') then
        return false
    else
        return true
    end
end

-- compare two docfile's: (see search.tlu for structure)
-- 1. by score
-- 2. then by extensions (ordered as in ext_list),
-- 3. then by tree,
-- 4. then lexicographically by filename.
-- return true if a is better than b
function docfile_order (a, b)
    if a.score > b.score then
        return true
    elseif a.score < b.score then
        return false
    elseif a.tree < b.tree then
        return true
    elseif a.tree > b.tree then
        return false
    else
        a.ext_pos = a.ext_pos or ext_pos(a.name)
        b.ext_pos = b.ext_pos or ext_pos(b.name)
        if a.ext_pos < b.ext_pos then
            return true
        elseif a.ext_pos > b.ext_pos then
            return false
        else
            return (a.name < b.name)
        end
    end
end

-- returns the index of the most specific extension of file in ext_list,
-- or config.ext_list_max + 1
function ext_pos(file)
    -- remove zipext if applicable
    file = parse_zip(file)
    -- now find the extension
    local p, e, pos, ext
    for p, e in ipairs(config.ext_list) do
        if (e == '*') and (ext == nil) then
            pos, ext = p, e
        elseif (e == '') and not string.find(file, '.', 1, true) then
            pos, ext = p, e
        elseif string.sub(file, -string.len(e)-1) == '.'..e then
            if (ext == nil) or (ext == '*')
                or (string.len(e) > string.len(ext)) then
                pos, ext = p, e
            end
        end
    end
    return pos or (config.ext_list_max + 1)
end

-- export a few symbols
export_symbols(L, {
    'sort_doclist',
    'docfile_quality',
})
