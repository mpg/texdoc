-- scoring functions for texdoc
--[[ 
Copyright 2008, 2009 Manuel Pégourié-Gonnard
Distributed under the terms of the GNU GPL version 3 or later.
See texdoc.tlu for details.
--]]

local L = {}
load_env(L, {
    'export_symbols',
    'string', 'table',
    'ipairs',
    'config', 'parse_zip',
})

-- sort a doclist
function sort_doclist(dl)
    set_list_scores(dl)
    dl.inv = nil -- wrong after a sort, and useless now
    table.sort(dl, docfile_order)
end

-- set the scores for a doclist
function set_list_scores(list)
    for _, df in ipairs(list) do
        set_score(df)
    end
end

-- set the score of a docfile
function set_score(df)
    local score = 0
    for _, pat in ipairs(df.matches) do
        local s = match_score(df.name, pat.name)
        s = s * pat.ratio
        if s > score then score = s end
    end
    df.score = score
end

-- compute a matching score:
-- 0 by default
-- 1 if pat is a sub-word of file
-- 2 if pat is the basename of file (w/o extension)
function match_score(file, pat)
    -- scoring is irrelevant in regex mode
    if config.mode == 'regex' then return 0 end
    -- be case-insensitive
    file = string.lower(file)
    pat = string.lower(pat)
    basename = string.gsub(file, '^.*/', '')
    -- look for exact match
    if basename == pat then return 2 end
    for _, ext in ipairs(config.ext_list) do
        if ext ~= '' and ext ~= '*' and basename == pat..'.'..ext then
            return 2
        end
    end
    -- look for sub-word match
    -- TODO: implement sub-word detection
    -- return default value
    return 0
end

-- compare two docfile's: (see search.tlu for structure)
-- 1. by score
-- 2. then by extensions (ordered as in ext_list),
-- 3. then by tree,
-- 4. then lexicographically by filename.
-- return true if a is better than b
function docfile_order (a, b)
    if a.score > b.score then
        return true
    elseif a.score < b.score then
        return false
    elseif a.tree < b.tree then
        return true
    elseif a.tree > b.tree then
        return false
    else
        a.ext_pos = a.ext_pos or ext_pos(a.name)
        b.ext_pos = b.ext_pos or ext_pos(b.name)
        if a.ext_pos < b.ext_pos then
            return true
        elseif a.ext_pos > b.ext_pos then
            return false
        else
            return (a.name < b.name)
        end
    end
end

-- returns the index of the most specific extension of file in ext_list,
-- or config.ext_list_max + 1
function ext_pos(file)
    -- remove zipext if applicable
    file = parse_zip(file)
    -- now find the extension
    local p, e, pos, ext
    for p, e in ipairs(config.ext_list) do
        if (e == '*') and (ext == nil) then
            pos, ext = p, e
        elseif (e == '') and not string.find(file, '.', 1, true) then
            pos, ext = p, e
        elseif string.sub(file, -string.len(e)-1) == '.'..e then
            if (ext == nil) or (ext == '*')
                or (string.len(e) > string.len(ext)) then
                pos, ext = p, e
            end
        end
    end
    return pos or (config.ext_list_max + 1)
end

-- export a few symbols
export_symbols(L, {
    'sort_doclist',
})
