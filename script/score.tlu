-- scoring functions for texdoc
--[[ 
Copyright 2008, 2009 Manuel Pégourié-Gonnard
Distributed under the terms of the GNU GPL version 3 or later.
See texdoc.tlu for details.
--]]

local L = {}
load_env(L, {
    'export_symbols',
    'string', 'table',
    'pairs', 'ipairs', 'tostring', 'tonumber',
    'config', 'parse_zip', 'err_print', 'deb_print',
})

-- shared variables
local setscore, adjscore = {}, {}

-------------------------   configuration directives   -------------------------

-- interpret a confline as a score directive or return false
function confline_to_score(line, file, pos)
    local key, val
    -- try setscore
    key, val = string.match(line, '^setscore%s+([%w%p]+)%s*=%s*(-?[%d]+)')
    if key and val then 
        local k = string.lower(key)
        if setscore[k] == nil then setscore[k] = tonumber(val) end
        return true
    end
    -- try adjscore
    key, val = string.match(line, '^adjscore%s+([%w%p]+)%s*=%s*(-?[%d]+)')
    if key and val then 
        local k = string.lower(key)
        if adjscore[k] == nil then adjscore[k] = tonumber(val) end
        return true
    end
    return false
end

----------------------------   score computation   -----------------------------

-- set the scores for a doclist
function set_list_scores(list)
    for _, df in ipairs(list) do
        set_score(df)
    end
end

-- set the score of a docfile
function set_score(df)
    -- scoring is irrelevant in regex mode
    if config.mode == 'regex' then df.score = 0 return end
    -- default score 
    local score = 0
    deb_print('score', 'Start scoring '..df.realpath)
    -- set from tables
    for pat, val in pairs(setscore) do
        if match_score(df.name, pat) > 0 then
            deb_print('score', string.format(
                "Set from pattern '%s': %d", pat, val))
            df.score = val
            return
        end
    end
    -- get score from patterns
    for _, pat in ipairs(df.matches) do
        local s = match_score(df.name, pat.name)
        s = s * pat.ratio
        if s > score then score = s end
        deb_print('score', string.format(
            "For pattern '%s': score %d ratio %d", pat.name, s, pat.ratio))
    end
    deb_print('score', 'Total pattern score: '..tostring(score))
    -- adjust from tables
    for pat, val in pairs(adjscore) do
        local s = match_score(df.name, pat)
        score = score + s * val
        deb_print('score', string.format(
            "Adjust pattern '%s': score %d, ratio %d", pat, s, val))
    end
    deb_print('score', 'Adjusted score: '..tostring(score))
    df.score = score
end

-- compute a matching score 0 <= s < 10 
-- 0 iff pat or a derivative doesn't match at least as a subword
-- >= 1 otherwise
function match_score(file, pat)
    -- be case-insensitive
    file = string.lower(file)
    pat = string.lower(pat)
    local score = 0
    -- look for exact match
    if is_exact(file, pat) then
        score = 2
    end
    -- look for subword match
    if is_subword(file, pat) then
        score = 1
    end
    return score
end

-- says if file is an exact match for pat
-- TODO: what to do is pat contains '/' ?
-- TODO: zipped
function is_exact(file, pat)
    basename = string.gsub(file, '^.*/', '')
    if basename == pat then return true end
    for _, ext in ipairs(config.ext_list) do
        if ext ~= '' and ext ~= '*' and basename == pat..'.'..ext then
            return true
        end
    end
    return false
end

-- say if pat is a "subword" of str
function is_subword(str, pat)
    local i, j = string.find(str, pat, 1, true)
    return not not (i and j
        and (i == 1 or is_delim(str, i) or is_delim(str, i-1))
        and (j == #str or is_delim(str, j) or is_delim(str, j+1)))
end

-- say if chararcter i of str is a delimiter (ponctuation)
function is_delim(str, i)
    return not not string.find(string.sub(str, i, i), '%p')
end

-- compare two docfile's: (see search.tlu for structure)
-- 1. by score
-- 2. then by extensions (ordered as in ext_list),
-- 3. then by tree,
-- 4. then lexicographically by filename.
-- return true if a is better than b
function docfile_order (a, b)
    if a.score > b.score then
        return true
    elseif a.score < b.score then
        return false
    elseif a.tree < b.tree then
        return true
    elseif a.tree > b.tree then
        return false
    else
        a.ext_pos = a.ext_pos or ext_pos(a.name)
        b.ext_pos = b.ext_pos or ext_pos(b.name)
        if a.ext_pos < b.ext_pos then
            return true
        elseif a.ext_pos > b.ext_pos then
            return false
        else
            return (a.name < b.name)
        end
    end
end

-- returns the index of the most specific extension of file in ext_list,
-- or config.ext_list_max + 1
function ext_pos(file)
    -- remove zipext if applicable
    file = parse_zip(file)
    -- now find the extension
    local p, e, pos, ext
    for p, e in ipairs(config.ext_list) do
        if (e == '*') and (ext == nil) then
            pos, ext = p, e
        elseif (e == '') and not string.find(file, '.', 1, true) then
            pos, ext = p, e
        elseif string.sub(file, -string.len(e)-1) == '.'..e then
            if (ext == nil) or (ext == '*')
                or (string.len(e) > string.len(ext)) then
                pos, ext = p, e
            end
        end
    end
    return pos or (config.ext_list_max + 1)
end

-----------------------------   public functions   -----------------------------

-- return the "quality" of docfile
function docfile_quality(df)
    if df.score > 0 then
        return 'good'
    elseif df.score > -100 then
        return 'bad'
    else
        return 'killed'
    end
end

-- sort a doclist
function sort_doclist(dl)
    dl:stop()
    set_list_scores(dl)
    table.sort(dl, docfile_order)
end

-- export a few symbols
export_symbols(L, {
    'sort_doclist',
    'docfile_quality',
    'confline_to_score',
})
