-- File searching functions for texdoc.
--[[ 
Copyright 2008, 2009 Manuel Pégourié-Gonnard
Distributed under the terms of the GNU GPL version 3 or later.
See texdoc.tlu for details.
--]]

-- Load a private environment for this submodule (see texdoc.tlu).
local L = {}
load_env(L, {
    'os', 'lfs', 'kpse', 'io', 'setmetatable', 'print',
    'dofile', 'loadfile', 'setfenv', 'rawget', 'rawset',
    'win32_hook', 'parse_zip',
    'get_patterns', 'sort_doclist', 'docfile_quality', 'ext_pos',
    'config',
})

-- Warning: every single function here assumes init_databases() has been called.

-- shared by all functions in this file
local s_doclist -- the Doclist objet to be populated by various functions
local s_meta -- {[normname] = meta, ...} (populated by init_tlp_database)

-----------------------   docfile and doclist objects   ------------------------

--[[
doclist = {
    [1] = docfile1, [2] = docfiles2, ...,
    inv = { realpath1 = index1, ... }
}

The inv subtable is such that for all i
doclist.inv(doclist[i].realpath) == i
--]]

local Doclist = {}
Doclist.__index = Doclist

-- create a new list of docfiles
function Doclist:new()
    local dl = { inv = {} }
    setmetatable(dl, self)
    return dl
end

-- add a docfile to a list
function Doclist:add(df)
    local index = self.inv[df.realpath]
    if index then
        self[index]:mergein(df)
    else
        local newindex = #self + 1
        self[newindex] = df
        self.inv[df.realpath] = newindex
    end
end

-- stops a doclist
function Doclist:stop()
    self.inv = nil
end

--[[
docfile = {
    -- name and tree are mendatory
    name     = filename (used for scoring only)
    tree     = code of the tree, see below
    -- at least one of the following fields should exist
    matches  = {pattern1, pattern2, ...}
    runtodoc = true if there is a runfile -> docfile association
    tlptodoc = true if there is a tlp name -> docfile association
    -- those are virtual members, see below
    meta     = metadata from the catalogue (tlpdb) as a plain string
    realpath = full path
}
if tree > 1, this is the index of the tree in TEXDOCS
if tree = 0, then name is relative to TLROOT (file found from tlpdb only)
tree = - 1 if and only if file is a sty file. Here name is absolute.
--]]

-- Docfile objects inherit members from Docfile
-- and have virtual members implemented by get_<member>() methods
-- for best cache performance, getters should not return nil
local Docfile = {}
function Docfile:__index(key)
    if Docfile[key] then return Docfile[key] end
    local getter = Docfile['get_'..key]
    if getter then
        rawset(self, key, getter(self))
        return rawget(self, key)
    end
end

-- create a new docfile objet using initilisation info
-- required fields: name, tree
function Docfile:new(info)
    local df = {}
    setmetatable(df, self)
    for k, v in pairs(info) do
        if k == 'pattern' then
            df.matches = { info.pattern }
        else
            df[k] = v
        end
    end
    return df
end

-- merge a second docfile objet in, assuming it represents the same file
function Docfile:mergein(df)
    for k, v in pairs(df) do
        if k == 'matches' then
            for _, m in ipairs(df.matches or {}) do
                table.insert(self.matches, m)
            end
        else
            self[k] = v
        end
    end
end

-- return the full path to the file
function Docfile:get_realpath()
    if self.tree > 0 then 
        return texdocs_tree_to_path(self.tree, self.name)
    elseif self.tree == 0 then
        return get_tlroot()..'/'..self.name
    else
        return self.name
    end
end

-- normalise a name from the tlpdb (use for s_meta indexes)
function reloc_tlpdb_path(name)
    return string.gsub(name, '^texmf[^/]*/doc/', '', 1)
end

-- return normalised name
function Docfile:get_normname()
    return (self.tree == 0) and reloc_tlpdb_path(self.name) or self.name
end

-- retrieve the associated meta information
function Docfile:get_meta()
    return s_meta[self.normname] or false
end

-- return the short name used for scoring
function Docfile:get_shortname()
    if self.tree == -1 then return self.name end
    local name = self.normname
    -- remove first component of name if at least two directory levels
    name = string.match(name, '^..-/(.+/.+)$') or name
    return '/'..name
end

-- return the base name
function Docfile:get_basename()
    return string.gsub(self.name, '.*/', '', 1)
end

-- for interface consistency, matches should always be a table, never nil
function Docfile:get_matches()
    return {}
end

-- from score.tlu
Docfile.get_quality = docfile_quality

-- from score.tlu
function Docfile:get_ext_pos()
    return ext_pos(self.basename)
end

---------------------   manage TEXDOCS trees à la kpse   ----------------------

do -- scope of doc_roots
local doc_roots

-- doc_roots is a Lua version of kpse's TEXDOCS
-- structure of the doc_roots variable:
-- doc_roots[i] = {
--     path                 = <path>,
--     index_mandatory      = <does path begin with !! in TEXDOCS?>
--     recursion_allowed    = <does path ends with // in TEXDOCS?>,
-- }

-- populate the doc_roots filename databases
function init_texdocs_database()
    doc_roots = {}
    local sep = (os.type == 'windows') and ';' or ':'
    local kpse_texdocs = kpse.expand_var("$TEXDOCS")
    -- expand the path and turn it into a lua list
    local raw_doc_roots = string.explode(kpse.expand_braces(kpse_texdocs), sep)
    local max = #raw_doc_roots + 1
    for j, dir in ipairs(raw_doc_roots) do
        local i = max - j
        local n
        local path, db
        -- get path, !! and // values
        dir, n = string.gsub (dir, '//$', '')
        local recursion_allowed = (n == 1)
        local path, n = string.gsub (dir, '^!!', '')
        local index_mandatory = (n == 1)
        deb_print('texdocs', string.format(
            'texdocs[%d] = %s (index_mandatory=%s, recursion_allowed=%s)',
            i, path, tostring(index_mandatory), tostring(recursion_allowed)))
        -- decide if we should use a ls-R index, the filesystem, or do nothing
        local root, shift = lsr_root(path)
        if root and shift and recursion_allowed then
            deb_print('texdocs', string.format(
                'texdocs[%d] using index: %s (shift=%s)', i, root, shift))
            db = init_lsr_db(root, shift)
        elseif not index_mandatory and lfs.isdir(path) then
            db = init_tree_db(path, recursion_allowed)
            deb_print('texdocs', string.format(
                'texdocs[%d] using filesystem search', i))
        end
        -- register this in docroots
        doc_roots[i] = { path = path, db = db }
    end
end

-- return the real path from a texdocs tree number + relative path
function texdocs_tree_to_path(tree, rel)
    return win32_hook(doc_roots[tree].path..'/'..rel)
end

-- find docfiles in texdocs directories
function get_doclist_texdocs(patlist)
    for code, dr in ipairs(doc_roots) do
        if dr.db then scan_db(patlist, code, dr.db) end
    end
end

end -- scope of doc_roots

-- find a ls-R file in a parent directory an return it or nil
function lsr_root (path)
    if not lfs.isdir (path) then return end
    local root, shift = path, ''
    if string.sub(root, -1) == '/' then root = string.sub(root, 1, -2) end
    while string.find(root, '/', 1, true) do
        if lfs.isfile(root..'/ls-R') then
            return root, shift
        end
        local last_comp = string.match(root, '^.*/(.*)$')
        -- /!\ cannot put last_comp in a regex: can contain special char
        root = string.sub(root, 1, - (#last_comp + 2))
        shift = last_comp..'/'..shift
    end
end

-- build a db from a ls-R file
function init_lsr_db(root, shift)
    -- open the file
    local lsr = assert(io.open(root..'/ls-R', 'r'))
    local _ = lsr:read('*line') -- throw away first line (comment)
    -- scan it
    local db = {}
    local maybe_dir, isdoc = true, false
    local current_dir
    local l = #shift
    while true do
        local line = lsr:read('*line')
        while line == '' do line, maybe_dir = lsr:read('*line'), true end
        if line == nil then break end -- EOF
        local dir_line = maybe_dir and string.match(line, '^%./(.*):$')
        if dir_line then
            maybe_dir = false -- next line may not be a dir
            if string.sub(dir_line, 1, l) == shift then
                isdoc = true
                current_dir = string.sub(dir_line, l+1)
                db[current_dir] = nil
            elseif isdoc then
                break -- we're exiting the ./doc (or shift) dir, so it's over
            end
        elseif isdoc then
            local file = current_dir..'/'..line
            db[file] = line
        end
    end
    lsr:close()
    return db
end

-- build a db for a tree without ls-R index
function init_tree_db(base, recurse)
    local db = {}
    local function init_tree_db_rec(dir)
        for file in lfs.dir(base..'/'..dir) do
            if file ~= '.' and file ~= '..' then
                local f = (dir == '') and file or dir..'/'..file
                if lfs.isdir(base..'/'..f) then
                    if recurse then init_tree_db_rec(f) end
                else
                    db[f] = file
                end
            end
        end
    end
    init_tree_db_rec('')
    return db
end

--------------------   select results from TEXDOCS trees   ---------------------

-- scan a database
function scan_db(patlist, code, lsr_db)
    for file, basename in pairs(lsr_db) do
        local df = process_file(patlist, basename, file, code)
        if df then s_doclist:add(df) end
    end
end

-- says if file has a 'good' extenstion according to ext_list
function check_ext(file)
    file = string.lower(file)
    -- remove zipext if applicable
    file = parse_zip(file)
    -- then do the normal thing
    for _, e in ipairs(config.ext_list) do
        if e == '*' then
            return true
        elseif (e == '') then
            if not string.find(file, '.', 1, true) then
                return true
            end
        else
            local dot_e = '.'..e
            if string.sub(file, -string.len(dot_e)) == dot_e then
                return true
            end
        end
    end
    return false
end

-- return a docfile object if file "matches", nil ortherwise
function process_file(patlist, file, pathfile, code)
    local docfile
    local pattern
    for _, pattern in ipairs(patlist) do
        if string.find(string.lower(pathfile), string.lower(pattern.name),
                1, config.mode ~= 'regex') then
            local good_ext = check_ext(file)
            if good_ext then
                local info = {
                    name    = pathfile,
                    tree    = code,
                    pattern = pattern,
                }
                if docfile then
                    docfile:mergein(Docfile:new(info))
                else
                    docfile = Docfile:new(info)
                end
            end
        end
    end
    return docfile
end

----------------------------   look for sty files   ----------------------------

-- add doclist entries for sty files in patlist
function get_doclist_sty(patlist)
    for _, pat in ipairs(patlist) do
        local file = kpse.find_file(pat.name)
        if file then
            local df = Docfile:new({
                name    = win32_hook(file),
                tree    = -1,
                pattern = pat,
            })
            s_doclist:add(df)
        end
    end
end

--------------------------------   use tlpdb   ---------------------------------

-- tlpdb mean TeX Live Package DataBase and tlp means TeX Live Package

-- find the TeX Live root
function get_tlroot()
    local tlroot = kpse.var_value('SELFAUTOPARENT')
    get_tlroot = function() return tlroot end
    return tlroot
end

do -- begin scope of tlp_from_runfile and tlp_doclist
local tlp_from_runfile -- { [runfile_basename] = {tlp1 = true, ...}, ... }
local tlp_doclist -- { [tlp_name] = { relname1, relname2, ...}, ... }

-- populate internal databases with information from tlpdb
function init_tlp_database()
    tlp_from_runfile, tlp_doclist, s_meta = {}, {}, {}
    local curr_tlp
    local state = 'none'
    for line in io.lines(get_tlroot()..'/tlpkg/texlive.tlpdb') do
        if state == 'none' and string.find(line, '^name ') then
            -- begin a new package
            curr_tlp = string.lower(string.sub(line, 6, -1))
            tlp_doclist[curr_tlp] = {}
        elseif state == 'docfiles' then
            if not string.find(line, '^ ') then
                state = 'none'
            else
                local file = string.match(line, '^ ([^ ]*)')
                local meta = string.match(line, '^ [^ ]* (.+)')
                if check_ext(string.lower(file)) then
                    -- we've got a docfile here, add it
                    table.insert(tlp_doclist[curr_tlp], file)
                    s_meta[reloc_tlpdb_path(file)] = meta
                end
            end
        elseif state == 'runfiles' then
            if not string.find(line, '^ ') then
                state = 'none'
            else
                -- check for interesting runfiles
                local e = string.sub(line, -4, -1)
                if e == '.tex' or e == '.sty' or e == '.cls' then
                    local f = string.match(line, '.*/(.*)%.')
                    tlp_from_runfile[f] = tlp_from_runfile[f] or {}
                    tlp_from_runfile[f][curr_tlp] = true
                end
            end
        end
        -- update state
        if string.find(line, '^docfiles ') then
            state = 'docfiles'
        elseif string.find(line, '^runfiles ') then
            state = 'runfiles'
        end
    end
    remove_useless_tlp()
end

-- remove entries for tlp with any docfile
function remove_useless_tlp()
    for tlp, doclist in pairs(tlp_doclist) do
        if #doclist == 0 then tlp_doclist[doclist] = nil end
    end
    for runfile, tlp in pairs(tlp_from_runfile) do
        if not tlp_doclist[tlp] then tlp_from_runfile[runfile] = nil end
    end
end

-- print out data from tlpdb in dofile()-able form
function print_out_tlpdb_data(filename)
    local esc = function(s) return string.format('%q', tostring(s)) end
    local fh = assert(io.open(filename, 'w'))
    -- s_meta
    fh:write('s_meta = {\n')
    for k, v in pairs(s_meta) do
        fh:write('  [', esc(k), '] = ', esc(v), ',\n')
    end
    fh:write('}\n')
    -- tlp_from_runfile
    fh:write('tlp_from_runfile = {\n')
    for k, v in pairs(tlp_from_runfile) do
        fh:write('  [', esc(k), '] = {')
        for f in pairs(v) do fh:write('[', esc(f), ']=true,') end
        fh:write('},\n')
    end
    fh:write('}\n')
    -- tlp_doclist
    fh:write('tlp_doclist = {\n')
    for k, v in pairs(tlp_doclist) do
        fh:write('  [', esc(k), '] = {\n')
        for _, f in ipairs(v) do
            fh:write('    ', esc(f) ,',\n')
        end
        fh:write('  },\n')
    end
    fh:write('}\n')
    fh:write('return s_meta, tlp_from_runfile, tlp_doclist\n')
    fh:close()
end

-- get pre-hashed tlpdb info from a file
function fast_init_tlp_database(filename)
    s_meta, tlp_from_runfile, tlp_doclist = dofile(filename)
end

-- dummy function for testing purpose
function no_init_tlp_database(filename)
    tlp_from_runfile, tlp_doclist, s_meta = {}, {}, {}
end

-- get docfiles for pattern using specific tlpdb information
function get_doclist_tlpdb(pattern)
    -- runfile to tlp to docfile
    if tlp_from_runfile[pattern] then
        for tlp in pairs(tlp_from_runfile[pattern]) do
            for _, file in ipairs(tlp_doclist[tlp]) do
                s_doclist:add(Docfile:new{
                    name        = file,
                    tree        = 0,
                    runtodoc    = true,
                })
            end
        end
    end
    -- tlp name to docfile
    if tlp_doclist[pattern] then
        for _, file in ipairs(tlp_doclist[pattern]) do
            s_doclist:add(Docfile:new{
                name            = file,
                tree            = 0,
                tlptodoc        = true,
            })
        end
    end
end

end --scope of tlp_from_runfile, tlp_doclist

------------------------------   main function   -------------------------------

-- initialise the various databases (must be called first)
function init_databases()
    init_texdocs_database()
    -- no_init_tlp_database()
    init_tlp_database()
    -- fast_init_tlp_database('./test-tlpdb.lua')
    -- print_out_tlpdb_data('./test-tlpdb.lua')
end

-- find docfiles according to pattern
function get_doclist(pattern)
    -- get patterns (inc. aliases)
    local normal, sty = normal_vs_sty(get_patterns(pattern))
    -- initialise result list
    s_doclist = Doclist:new()
    -- get results
    get_doclist_sty(sty)
    get_doclist_texdocs(normal)
    get_doclist_tlpdb(pattern)
    -- finally, sort results
    sort_doclist(s_doclist, pattern)
    return s_doclist
end

-- separate sty patterns from the rest
function normal_vs_sty(list)
    if config.mode == 'regex' then return list, {} end
    local normal, sty = {}, {}
    for _, p in ipairs(list) do
        if string.match(string.lower(p.name), '%.([^/.]*)$') == 'sty' then
            table.insert(sty, p)
        else
            table.insert(normal, p)
        end
    end
    return normal, sty
end

-- finally export a few symbols
export_symbols(L, {
    'init_databases',
    'get_doclist',
})
